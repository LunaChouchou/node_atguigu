## 入门
- nodejs.org
  - runtime environment
- cmd
  - dir /s 显示所有文件内容
  - d: 切换到d盘
- NodeJS编码注意事项
  - 浏览器中的JavaScript
      - ES, DOM, BOM, AJAX, Storage, **console, 定时器**, alert/confirm...
  - Node.js中的JavaScript
      - fs, url, http, util, **console, 定时器**, path...
- 不能使用BOM和DOM的API
  - global, globalThis 访问顶级对象 相当于window

## Buffer
- 介绍与创建
  - 创建x字节的Buffer 1byte=8bit 2位16进制=8位2进制
  - Node在启动时已经加载进来 不需要手动导入 Buffer全局变量
    - alloc 全部归零
    - allocUnsafe 可能会包含旧的内存数据 不会对旧数据清零 速度更快
    - from 一个字符串or数组转为buffer
      - Unicode（兼容ASCII）字符（包含数字）对应的2进制数字
- 操作与注意点
  - **buf 直接输出Buffer 2进制的Buffer 显示为16进制**
    - `console.log(buf)`
    - `<Buffer 68 65 6c 6c 6f>`
  - **buf.toString() 2进制的Buffer→字符串 默认utf8**
    - `console.log(buf.toString())`
    - `hello`
  - Buffer类似于数组 buf[0]返回的是一个10进制的数字
    - 可以更改元素 buf[0]=95
  - **buf[0] 输出数组元素 10进制（的数字）**
    - `console.log(buf[0])`
    - `104`
  - **buf[0].toString(2) 10进制（的数字！）→2进制（的字符串！）**
    - `console.log(buf[0].toString(2))`
    - `1101000`
      - buf[0]没有Ox之类的前缀 所以是10进制
      - 第1位是符号位 1时是负数
  - 溢出
    - 255以内
    - 舍弃高位的数字 只取右边的8位
    - 相当于取模 mod256
  - 中文
    - utf-8的中文 一般占3个字节

## 计算机基础
- 进程和线程
  - 线程是一个进程中执行的一个执行流

## fs模块
- 写入文件
  - fsAPI file system
  - 实现与硬盘的交互
  - 导入模块 
    - `const fs = require('fs');`
    - require全局函数
      - import是es6语法 异步导入 执行到用的时候导入
      - require是commonjs 同步导入 执行到require的时候导入
  - `fs.writeFile('路径', '内容', [option], 接err回调函数)`
    - 成功时返回null
- 同步与异步
  - `writeFile` 异步
    - JS主线程
    - I/O线程
    - write结束后 回调函数压入到任务队列中执行
    - 主线程不等待write结果直接执行
  - `writeFileSync('路径', '内容', [option])` 同步
- fs追加写入
  - `appendFile('路径', '内容', [option], 接err回调函数)`
      ```js
      err=>{
      if(err){}} //错误对象强制转boolean是true
      ```
  - `appendFileSync('路径', '内容', [option])`
  - fs模块中加入换行是/r/n 不是<br>
  - writeFile的option写{flag: 'a'} 可以追加写入 a:append
    - w 写入
    - a 追加
    - r 读取
- 文件流式写入
  - `createWriteStream('路径', [option])` 建立通道
  - `ws.write('内容')`
  - `ws.close`
    - 脚本执行完毕后会自动关闭资源
- 文件写入应用场景
  - git add -A 存入object文件夹
  - git/logs/HEAD
- fs文件读取
  - `readFile('路径', [option], 接err+data回调函数)`
    - 全部读到内存中
    - data文件信息 是一个buffer data.toString
  - `readFileSync('路径', [option])`
- 读取文件应用场景
  - git log 读取文件
- fs流式读取
  - 一部分一部分地读到内存中
  - 处理大文件时提高效率
  - `createReadStream('路径', [option])`
  - `rs.on('data',接chunk回调)` 绑定data事件 每次读取一次数据执行一次回调
    - 每次65536字节 64KB
  - `rs.on('end', 回调)` end事件
- fs练习 文件复制
  - 读取速度一般比写入速度快
    - 读了很多条 一条一条排队写
  - `process.memoryUsage()`
    - 此process
    - rss整个占用内存大小
    - （连续执行会变大）
  - `rs.pipe(ws)` 复制 用得不多
- fs文件重命名与移动
  - `fs.rename('路径', '新路径', 接err回调函数)`
  - `fs.renameSync('路径','新路径')`
- fs文件删除
  - `unlink('路径', 接err回调函数)`
    - `unlinkSync('路径')`
  - `rm('路径', 接err回调函数)`
    - `rmSync`
- fs文件夹操作
  - 创建
    - `mkdir('路径', [option], 接err回调函数)`
    -  `{recursive: true}` 递归创建option
  - 读取
    - `readdir('路径', 接err+data回调函数)`
      - data返回数组 文件夹和文件名
  - 删除
    - `rmdir('路径', 接err回调函数)` depricated
      - 只能删空文件夹
    - `{recursive: true}` 递归删除option
    - `rm` 建议使用
  - 都有Sync版本
- fs查看资源状态
  - `('路径', 接err+data回调函数)`
    - err和data都是对象
      - atime 最后访问
      - mtime 最后修改
      - ctime 最后修改文件状态
      - birthtime 创建
      - `data.isFile()` `data.isDirectory()` 判断文件or文件夹
  - `statSync`
- fs路径
  - D:/...
  - /... 盘符根目录
- fs相对路径的bug
  - fs（js全般）相对路径的参照物不是js文件所在目录 而是命令行工作目录
    - 与是不是入口文件、直接执行脚本/服务器上开启项目无关 只与node命令工作目录有关
  - 扩展：工作目录/文件所在目录
    - 本文件378行附近 live-server开启根目录为vscode打开的文件夹
    - 工作目录
      - 执行`node myScript.js`时 读到js文件中有相对路径的语句
    - 文件所在目录
      - 在模块中引入其他模块时require语句
        - 个人理解：src下文件编译时会被构建工具处理 所以根据编译前文件夹结构使用相对路径没有问题
      - html引入css文件
        - 针对public下文件的个人理解：
          - public文件夹下内容不会被编译 所以根据文件夹结构引入没有问题
          - public文件夹浏览器有机会直接请求 在浏览器请求时 这些文件所在目录/文件内相对路径中包含的根目录public会被替换成基本URL 所以public下的资源还会有对基本URL的解释产生分歧而造成的问题（见react_staging_12_使用路由样式丢失问题 为什么路由路径会让基本URL发生偏差未能理解 路由应该指的是浏览器地址栏里写的东西用于浏览器判断当前要显示的页面 基本URL应该更偏向浏览器内部发送请求的地址）
  - `__dirname` like全局变量 所在文件的目录的绝对路径
    - 在服务器上开启的项目会返回生成文件所在的目录（C:/path... /path...之类的） 可能与源代码内文件位置有所不同 是一个机械性行为
- fs练习 批量重命名
  - 遍历数组 forEach(item => {})
  - 元素拆分 item.split('-') 拆分后是数组
  - 数组解构赋值 let [num, name] = data; num和name是变量名
    - 等效代码
      ```js
      let num = data[0];
      let name = data[1];
      ```
  - Number(num) 强制类型转换 String→int
  - 豆知识：`` 模板字符串 可以更方便地构建包含变量值${xx}的字符串，而不需要使用字符串拼接或连接符号

## path模块
- 导入path模块
- resolve(绝对路径,相对路径) 分析出正确路径
  - __dirname 分隔符是\ 
  - /index.html是一个绝对路径
  - (绝对路径1,绝对路径2,相对路径) →绝对路径2+相对路径
- sep 分隔符
  - 设定本系统的分隔符 win \ linux /
- parse方法 获取路径相关信息
  - `__filename` like全局变量 文件绝对路径
  - \ 转义字符 `\\` 给\加上一个转义字符 正确输出\
  - `parse(路径)`  root盘符，dir文件夹路径，base文件名+扩展名，ext扩展名，name文件名
- basename方法 获取文件名
- dirname方法 获取路径
- extname方法 获取扩展名 .js

## http协议
- http报文
  - fiddler软件 查看报文 burpsuit
- 请求报文结构
  - **请求行**
    - 请求方法
      - GET 获取
      - POST 新增
      - PUT/PATCH 更新
      - DELETE 删除
      - HEAD, OPTIONS, CONNECT, TRACE
    - URL
      - 协议名://主机名:端口号/路径?查询字符串
    - HTTP协议版本号
  - **请求头**
    - 键值对组成 记录浏览器相关信息 交互行为
  - 空行
  - **请求体**
    - 键值对、JSON形式
- 响应报文结构与响应行
  - **响应行**
    - HTTP版本号
    - 响应状态码 响应状态的描述
      - 200成功 OK
      - 403禁止请求 Forbidden
      - 404找不到资源 Not Found
      - 500服务器内部错误 Internal Server Error
        - 1xx信息响应
        - 2xx成功响应
        - 3xx重定向消息
        - 4xx客户端错误响应
        - 5xx服务器错误响应
  - **响应头**
    - 标准/自定义响应头
    - Content-Type
  - 空行
  - **响应体**
    - HTML, CSS, JS, 图片, 视频, JSON

## 网络基础概念
- IP
  - 32bit的2进制 4字节
- IP分类
  - 共享IP
    - 区域共享 家庭共享
      - 路由器IP 广域网IP/公网IP
        - 下述以外
      - 给各个端末分配局域网IP/私网IP
        - 192.168.0.0~192.168.255.255
        - 172.16.0.0~172.31.255.255
        - 10.0.0.0~10.255.255.255
      - 本地回环IP地址
        - 127.0.0.1~127.255.255.254 指代当前本机
- 端口
  - 应用程序的数字表示 0~65505 应用程序之间通信

## http模块
- 01_创建HTTP服务端
  - 1导入http模块
    - `require('http');`
  - 2server = http.createServer(回调) 对象.方法
    - `const server = http.createServer((request, response) => {`
    - 接收一个函数实参 匿名/箭头/function都可 接收到http请求时执行
      - 该函数接收2个形参
      - 该函数内部调用的时候接收2个实参
        - 请求报文的封装对象 request
          - 获取请求行、请求体等 request.xxxx
        - 响应报文封装对象 response
          - 设置响应头、响应体等 response.end
  - 3监听端口，启动服务
    - `server.listen(9000, () => {`
    - 选择端口号
    - 回调函数
      - 启动成功后执行
- http服务注意事项
  - 热部署 nodemon库
  - 设置响应头setHeader 设置字符集 解决中文乱码
  - http默认端口80 https443 主机名=IP地址
  - 资源监视器リソースモニター找到对应端口使用程序
    - 侦听端口リッスンポート
- 02_浏览器查看HTTP报文
  - 浏览器每次都会发送一个favicon.ico的请求
  - 大多数get请求的请求体是空的
  - 开发者工具 network
    - **标头标签页**
      - 请求标头
        - 请求头
        - 查看源代码 请求行+请求头
      - 响应标头
        - 响应头
        - 查看源代码 响应行+响应头
    - **载荷标签页**（有请求体时显示※）
      - 请求体（已格式化）
        - 查看源代码 原始请求体内容
      - url查询字符串（已格式化）（属于GET参数 非请求体※矛盾）
    - **响应标签页**
      - 原始响应体内容
- **request.param**
  - 03_获取请求行和请求头
    - 请求行 `request.method/url/httpVersion`
    - 请求头 `request.headers` 对象
      - 双拼词有一个单引号包起来
      - `request.headers.host`
  - 04_获取请求体
      ```js
      let body = '';
      request.on('data', chunk => {
      request.on('end', () => {
      ```
    - 现在url的路径怎么变都只会响应相同的内容 没有设定
    - chunk是一个Buffer 做加法运算会自动转换成字符串
    - 监听方法on
      - 附加函数方法到特定的事件 包括数据流中的事件
      - 多使用事件来处理异步操作
        - 绑定data事件 接收到数据时触发
        - 绑定end事件 数据传完时触发
        - （response.end 返回响应体）
    - post的表单内容会在请求体里
- **url.method/param**
  - 05_获取请求路径与查询字符串
    - 导入url模块 用于解析url的
    - `let res = url.parse(request.url)` 对象
      - `res.pathname` pathname属性 路径 基本URL右侧 /开始内容
      - query
        - search属性 '?keyword=h5'
        - query属性 'keyword=h5'
        - 都是字符串
    - `url.parse(request.url,true)` query属性将会被传递为一个对象
      - [Object: null prototype] 提示这个对象的原型是null
      - `res.query.keyword`
      - 如果请求里不含keyword 返回undefined
  - 06_获取请求路径与查询字符串(新)
    - 实例化URL对象 
      - `let url = new URL();`
        - 1个参数 完整URL
        - 2个参数 拼成完整URL
          - 相对URL,基本URL→基本URL+相对URL
          - 完整URL,参数2→完整URL
          - 基本URL：协议~主机名(端口)的部分
        - 返回1个对象 属性包括URL的各个部分
        - `url.search` 字符串形式query
        - `url.searchParams` 对象形式query
          - `get('keyname')` 取出 因为是map形式
          - 没有键对应的值的话会输出null 原型URLSearchParams设计成这样的
      - 前端JS也可以这样实例化
- 07_http模块练习_HTTP请求练习
  - 1次请求只能对应1个end方法
  - 需要定义url不符合预期的情况 不然没有response
- 08_设置HTTP响应报文
  - `response.statusCode = nnn` 设置响应状态码
    - 不设置默认200
    - 可多次使用 覆盖上次内容
  - `response.statusMessage = 'xxx'` 设置响应状态描述
    - 不设置默认跟随状态码
  - `response.setHeader('key','value')` 设置响应头
    - 内容设置数组可以设置多个同名响应头 比如set-cookie
  - `response.write` 设置响应体
    - 可多次使用 返回多个内容
    - 一般用了write 在end里就不设置响应体了
- 09_练习_HTTP响应练习
  - 响应体返回标签 浏览器渲染
  - 豆知识：`` 反引号 可以带换行
  - `table tr:nth-child(odd)`只设置单数行的css
  - js代码 <script>标签内写
- 10_练习_响应文件内容
  - `end(fs.readFileSync(pathOfHtml))`
  - end方法参数可以是字符串or buffer
  - 修改外部文件内容可以不用重新启动服务
- 网页资源加载基本过程
  - /资料/page
  - 无关请求
    - ws请求 vscode插件 让浏览器发送的 自动刷新功能
    - favicon.ico请求 浏览器自动行为
  - 请求顺序
    - index.html请求 获取html内容
    - index.css请求 读到需要index.css时发送http请求
    - h5.png请求 读到需要图片时发送请求
      - 没有响应体 看预览标签页
    - index.js请求 读到需要js时发送请求
  - 异步请求 并行发送
- 11_练习_响应练习扩展 实现网页引入外部资源
  - index.css link标签引入
  - index.js <script src="./index.js">引入
  - response回调函数需要定义不同请求的响应
    - url.pathname判断
- 静态资源和动态资源
- 12_搭建静态资源服务
  - 同步fs回调函数不接err 有处理方法
- 静态资源目录/网站根目录
  - `let root = __dirname + '/page';` 放静态资源的文件夹
    - 根目录/pathname
  - live-server/hbuilder/webstorm插件启动服务时根目录是vscode打开的文件夹（よくわからん）
    - live-server默认端口5050 URL→localhost:5050/文件位置/文件名
- 13_网页中的URL-绝对路径
  - 不带协议 //xxx.com
    - 复制粘贴一下可以显示和当前网页协议拼接后结果
    - 发送后服务器端返回301重定向 重新发送请求
  - 不带基本URL /xxx
    - 和当前网页基本URL拼接
    - 未来可能更换主机名的网站用得多
- 13_网页中的URL-相对路径
  - 如果../是基本URL ../../还会在基本URL
  - 相对路径参照当前页面URL 不可靠 
- 13_网页中URL使用场景小结
  - 相对路径 ./css/app.css 随着页面URL变化而变化 不可靠
  - 绝对路径 /css/app.css 与协议IP端口号拼接
- 13_设置MIME类型
  - 媒体类型/资源类型
  - 设置响应头 返回类型
    - 非必须 浏览器有mime嗅探功能
  - `path.extname(文件路径)` 获得扩展名 .html
  - `path.extname(文件路径).slice(1)` 从字符串/数组第1个元素开始截取 html
  - `mimes[ext]` mimes对象中以ext为下标的值 `对象[属性]`
  - 不知道的类型选下载文件类型
- 13_解决乱码问题
  - 1设置响应头 *优先级更高
  - 2meta标签
  - 外部资源没有必要设置字符集 js, css, 图片..
    - 直接打开还是会乱码
    - but在资源回到网页时 会根据网页html字符集做解析
- 13_完善错误处理
  - err是一个对象 code错误类型
- 13_GET和POST场景与区别
  - GET参数在URL后 POST在请求体中（不绝对）
  - GET上限2K

## 模块化
- Node.js模块化介绍
  - 1个文件就是1个模块
- 01_模块化初体验
  - `module.exports = tiemo;` 暴露1个数据
- 02_模块暴露数据
  - ①`module.exports` exports是1个属性
    - 暴露多个数据 包成1个对象
      ```js 
      module.exports = {
        tiemo:tiemo, 
        niejiao:niejiao
      }
      ```
  - ②`exports` exports是1个独立变量
    - `exports.tiemo = tiemo;`
    - 暴露多个写多个
  - exports = module.exports = {} 指向相同
    - require的返回结果是目标模块中module.exports的值而非exports
    - `exports = tiemo;``exports = {tiemo:tiemo};` 错误 重新赋值了exports
    - `module.exports.tiemo = tiemo;` 正确
- 03_Node.js导入模块
  - fs模块推荐绝对路径
  - require推荐相对路径 不会被工作路径影响
  - json文件不用暴露
  - 省略js/json后缀时 同名优先js
  - 其他扩展名/无扩展名 默认js
- 04_导入文件夹的情况
  - package.json和index.js都没有的话就不能导入文件夹
    - 需要精确到导入的js文件（main指示或文件名index）
- 05_require导入的基本流程
  - `arguments.callee.toString()` 函数代码
    - fromGPT：模块的加载过程会被包装在一个函数中执行，这个函数的签名看起来与传统的函数定义很相似，这个函数被称为模块的包装函数（Module Wrapper Function）。
  - `(function (){})()` 立即执行函数
  - 把模块对象缓存
  - 自定义模块/内置模块/外部包
- CommonJS模块化规范

## 包管理工具
- 包管理工具介绍
- npm介绍与安装
- npm初始化包
  - `npm init` 创建一个新包
    - 默认以工作文件夹名作为包名
    - `npm init -y` `npm init -yes` 快速创建
- npm搜索包
  - `npm s/search 关键字`
  - npmjs.com
- npm下载安装包
  - `npm i/install 包名`
  - 初始化（init）包后再下载安装包（install）
  - package-lock.json 包含包和依赖包的信息
  - require(包名)=导入内置模块
- require导入npm包的基本流程
  - require(相对路径)也OK
  - 文件夹下package.json内main的值（模块化_04）
  - 当前文件夹下没有node_modules会往上找node_modules
- 开发依赖与生产依赖
  - `npm i -S/--save`
    - 生产依赖包 开发生产都用 dependencies 默认
  - `npm i -D/--save-dev`
    - 开发依赖包 开发用 生产不用 devDependencies
- npm全局安装
  - `npm i -g`
  - 不受工作目录位置影响
  - `npm root -g` 查看全局安装包位置
- 修改windows执行策略
  - `set-ExecutionPolicy remoteSigned` 让powershell允许全局安装
  - cmd和其他工具不需设置
- 环境变量Path
  - 类似于数据库索引
  - 地址栏输入cmd 以文件夹为工作目录打开命令行
  - 找 某命令.exe/.cmd
    - 当前文件夹→环境变量Path列表
  - 在任意位置都能打开某命令程序
    - 环境变量-Path变量（本用户）/系统变量（所有用户） 配置
    - 打开新的命令行窗口 适用
- npm安装 包的所有依赖
  - `npm i/install` package.json, package-lock.json
  - `npm i 包名@x.x.x` 安装版本包
  - `npm r/remove -g 包名` 删除包
- npm配置命令别名
  - scripts server "xxxx"
    - `npm run server`
  - scripts start "xxxx"
    - `npm run start` `npm start`
  - run向上寻找
- cnpm介绍
  - 淘宝镜像 & 全局工具包
    - 可以同步、搜索包
  - `npm install -g cnpm --registry=https://registry.npmmirror.com`
- npm配置淘宝镜像
  - npm也可以下载淘宝镜像包
  - `npm config set registry https://registry.npmmirror.com/` 直接配置
  - nrm工具 工具配置
    - `npm i -g nrm`
    - `nrm use taobao` 切换镜像地址
    - `nrm ls` 查看镜像地址
    - `nrm config list`查看指向
- yarn介绍
  - `yarn init`
  - `yarn add xxxx`
  - `yarn add xxxx --dev`
  - `yarn` 安装所有包 相当于i
  - `yarn remove xxxx`
  - 别名 package.json scripts server "xxxx"
    - `yarn server` 无需加run
  - `yarn global add xxx`全局安装不好使 
    - `yarn global bin`查看全局安装包位置
    - 没有配置到环境变量Path中 需要手动配置
- npm和yarn的选择
  - `yarn config set registry https://registry.npmmirror.com/`配置淘宝镜像
  - `yarn config list`查看指向
  - yarn.lock 固定包版本
  - package-lock.json npm和cnpm的锁文件
- npm发布一个包
  - 跳过
- npm更新与删除包
  - 跳过
- 包管理工具扩展介绍
- nvm介绍与使用
  - 管理node版本
  
