# 会话控制
- 会话控制介绍
  - cookie, session, token
- Cookie的介绍
  - 浏览器 与域名相关
  - 请求头项目叫cookie 也可以理解成就是一个请求头
  - 内部本质是一些键值对
  - 响应头set-cookie 通过响应报文传递 浏览器解析保存cookie
- 浏览器中操作cookie
  - 用得比较少
  - 不同浏览器cookie不共享
  - 某网站使用其他js css 会用到其他域名的cookie 第三方cookie
- express中设置cookie
  - 步骤
    1. 不用express-generator新建一个express项目
      - 根目录下`npm init`
      - `npm i express`
      - `nodemon .\01_cookies.js`
    2. 创建/set-cookie路由规则
      - `res.cookie`返回cookie cookie名'name' 值'zhangsan'
    3. 向/set-cookie发送请求
      - 请求报文里没有cookie 正常
      - 响应头里有set-cookie: name=zhangsan 要求浏览器保存cookie
      - 浏览器保存cookie信息name
      - 点击URL左边的i查看此时的cookie
    4. 再次发送请求
      - 请求报文里有cookie: name=zhangsan
      - 这种会在**浏览器关闭时**销毁 在此之前向同域名发送的请求都会包含cookie
  - 7天免登录
    - 设置生命周期 res.cookie第3个参数可以设定 {maxAge: 60 * 1000} 值单位ms
    - 响应头set-cookie指示浏览器保存该cookie for 60s
      - 响应头里的数字单位s Expires是0时区时间需要加8h 日本9h
    - 此后**60s内**请求头内都会有cookie: name=lisi 关闭浏览器不会销毁
    - fromGPT：服务器端不会主动无效化该cookie 可以通过发送max-age=0的cookie来促使服务器端删除
- express中删除cookie
  - 步骤
    1. 创建/remove-cookie路由规则 示例代码用get
    2. `res.clearCookie('键')`
       - 多项内容显示多项set-cookie行
    3. 向/remove-cookie发送请求
    4. 响应报文返回name=;Expires=1970
- express中读取cookie
  - 安装cookie-parser包 `npm i cookie-parser`
    - npmjs.com 解析请求中的cookie
  - 导入包 require
    - 类似body-parser包
  - 设置中间件 app.use(cookieParser());
  - 新建路由规则/get-cookie
    - req.cookies 获取cookie
  - 向/get-cookie发送请求
    - 响应报文收到set-cookie
  - 再次发送请求
    - 请求报文包含cookie
  - 服务端可提取req.cookies
- session的介绍
  - 与用户建立连接 服务器创建session对象
    - 以响应cookie的形式返回session_id
    - 浏览器保存该cookie向服务器发送请求
    - 服务端通过sid识别客户端身份
- session举例说明
- session中间件配置 express-session安装与配置
  - `npm i expresss-session`操作session
    - 默认保存到内存
  - `npm i connect-mongo`连接mongodb进行操作
    - 将session信息存到db中
  - require引入
  - 使用示例代码注册中间件
  - `app.use(session({}));`
    - session接受1个对象 返回1个函数
      - name 响应cookie的名字 'sid'
      - secret 秘钥 加盐 提高安全等级
      - saveUninitialized 是否自动创建session对象
      - resave session超时
      - store 设置mongodb连接URL
      - cookie 设置响应内cookie的特性 设置的是set-cookie内的cookie
        - httpOnly set-cookie:sid=xxxx;httpOnly 仅传输使用 使前端js不能对该cookie访问
        - 不加可通过document.cookie获取 不太安全
- express中session操作
  - 开启mongod 开启02_session.js db会新建一个sessions集合
  - 新建get/login路由规则 登录
    - 设置生成session
      - `req.session.xxx = 'xxxx'`
      - db中保存session
        - _id 即sid
    - 响应 res.send
    - 发送login请求
      - 返回set-cookie包含sid
  - 新建get/cart路由规则 读取session
    - 判断session里是否存在用户数据
    - 使用了connect-mongo可以直接取得req.session
  - 新建get/logout路由规则 销毁session
    - `req.session.destroy(()=>{成功后操作})`
- session和cookie的区别
## 案例功能完善_记账本_session
- 01_响应注册页面
  - 新建auth.js路由reg路由规则 用ejs渲染reg页面
  - app.js导入auth.js 注册router中间件
  - 新建reg.ejs
  - views下文件过多可以归档 新建auth文件夹
    - 更新auth.js路由规则下路径为auth/ejs
- 02_注册用户
  - reg.ejs
    - 添加user和pw的name属性 必须
    - 添加表单post和aciton
  - auth.js添加post路由
  - 创建用户模型
  - auth.js
    - 在post路由应做表单验证（保证收到的req.body与db结构一致 插入时不会出现错误）
    - 导入模型
    - 插入db
      - `create(req.body)`和`create({...req.body})`效果相同 后者防止修改原始数据
    - 给密码加密 md5包 单向加密 不可逆
      - `npm i md5`
      - 导入md5
- 03_用户登录
  - auth.js添加登录页面路由规则
  - 新建登录ejs
  - 查询数据库 若查询不到data返回null 不会走error
    - 需要判断data是否为空
- 04_写入session
  - `npm i express-session connect-mongo`
  - 引入到app.js 设置express-session中间件
    - 导入配置文件 定义URL 使用占位符要用``包起来 ''不行
  - 登录路由规则 写入session
    - `req.session.username = data.username;`
    - data._id 文档id data.session._id sid
- 05_用户登录检测
  - if(req.session.username)
    - fromGPT：
      - req.session 实际上是服务端在处理请求时，根据请求cookie中的 session ID 从数据库中加载到内存中的 session 数据对象
      - 如果在请求处理中修改了 req.session，修改后的数据会在响应发送回客户端之前被保存回 MongoDB 中
  - 封装中间件
    - 管理中间件 新建middleware文件夹
    - 导入到index.js 注册中间件到路由规则
- 06_退出登录
  - auth.js添加get/logout路由规则
    - 销毁session`req.session.destroy`
  - 添加退出登录a链接
- 07_CSRF跨站请求伪造
  - 情况：attack.html中包含/logout请求 account会退出登录
  - 跨站 b网站往a网站发请求 还携带了a网站的cookie
  - 解决：把退出登录的请求改为post a改为form
  - 原因：link, image, script这些标签在加载过程中也会发请求 但都是get
  - 尽量用post
- 08_首页和404页面
  - 在index.js添加首页路由规则
    - / → /account → 检查登录 → /login
    - 调整导入语句位置 放在上面
    - var, let换成const
  - 在app.js自带404配置
    - 新建404.ejs模板
    - 如果想插入图片 保存位置要在public下
  - 公益404
# Token介绍
- token的介绍
  - 主要用于app 网页中session和cookie用得多
  - 校验用户身份之后创建
  - 包含用户信息
  - cookie自动携带 token手动携带
    - 不能自动携带所以可以避免CSRF
  - from弹幕：session不能跨服务器 可以保存在redis上
- jwt介绍与使用
  - json web token
  - 步骤
    - 初始化npm包
    - `npm i jsonwebtoken`下载包
    - 导入jwt
    - 生成token
      - 验证身份后
      - `jwt.sign(用户数据(一般是对象), 加密字符串, 配置对象)`
      - 配置对象expiresIn单位s
      - 会返回一个token值
    - 校验token
      - 后续请求
      - `jwt.verify(token, 加密字符串, 接err和data的回调函数)`
## 案例功能完善_记账本_token
- 01_登录响应token
  - 现状：api端没有验证身份
  - 步骤
    - 创建一个api端auth.js
    - 登录操作 修改response为res.json
      - 失败code定为200x api用
    - 把写入session改为响应token
      - 安装jwt`npm i jsonwebtoken`
      - jwt.sign
      - 导入auth.js
    - app.js中导入api/auth.js 注册
    - 用postman测试
- 02_token校验
  - 往api/account.js中加入token校验中间件
    - 导入jwt
  - 客户端的token如何传递由服务端决定 一般放在请求头 名字不固定 token/tk/userkey
  - 封装校验中间件 注册 移动到mw文件夹下
- 03_token功能完善
  - 秘钥有复用 转移到配置文件
    - 导入到api/auth.js和checkTokenMiddleware.js
  - 校验token后应该保存用户信息
    - 现在只是通过身份校验可以看到所有账单 将来需要特定该用户显示特定账单
    - 从token读取用户信息到req里 后续请求可以获得用户信息进而查询db等等
- 04_本地域名配置
  - 修改"C:\Windows\System32\drivers\etc\hosts"
  - 换行写入 127.0.0.1 www.myaccount.com 中间可多个空格
  - http://www.myaccount.com:3000 访问
  - 在www文件中把端口号改为80就可以不用在地址栏写端口号了
    - process.env.PORT 获取当前程序环境变量
  - hosts配置域名和ip的映射
    - 浏览器dns缓存→hosts→DNS